<!-- Autogenerated by mlir-tblgen; don't manually edit -->

# 'chlo' Dialect

_Client HLO Ops_

This dialect contains ops that align closely with the API surface area
of the XlaBuilder C++ API, where such ops have semantics that go beyond
what exists in the lower level dialects (such as `stablehlo`). Essentially,
whenever the client library uses syntactic sugar or composition
of multiple ops for an API call, this dialect tries to model the API call
and provide conversion patterns to fully materialize into lower level
dialects.

[TOC]

## Operations

### `chlo._asin_acos_kernel` (chlo::AsinAcosKernelOp)

_AsinAcosKernel operator_

Syntax:

```
operation ::= `chlo._asin_acos_kernel` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `AsinAcosKernel(operand)` element-wise.

If
  w = _asin_acos_kernel(z)
  w' = _asin_acos_kernel(I * z)
then
  asin(z) = complex(atan2(z.real, w.real), sign(z.imag) * w.imag)
  acos(z) = complex(atan2(w.real, z.real), -sign(z.imag) * w.imag)
  asinh(z) = complex(sign(z.real) * w'.imag, atan2(z.imag, w'.real))
  acosh(z) = complex(w.imag, sign(z.imag) * atan2(w.real, z.real))

This op is used as an intermediate value in decompositions and
should never be constructed directly by frameworks or consumed by
backends.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of complex |



### `chlo.acos` (chlo::AcosOp)

_Acos operator_

Syntax:

```
operation ::= `chlo.acos` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Acos(operand)` element-wise.

$$
\acos(x) = 2 * \atan(\sqrt(1 - x^2) / (1 + x)) if x != -1
         = pi                                  if x == -1
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.acosh` (chlo::AcoshOp)

_Acosh operation_

Syntax:

```
operation ::= `chlo.acosh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Acosh(operand)` element-wise.

$$
\acosh(x) = log(x + sqrt(x^2 - 1))      if x >= -1
\acosh(x) = nan                         if x < -1
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.asin` (chlo::AsinOp)

_Asin operator_

Syntax:

```
operation ::= `chlo.asin` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Asin(operand)` element-wise.

$$
\asin(x) = 2 * atan(x / (1 + sqrt(1 - x^2)))
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.asinh` (chlo::AsinhOp)

_Asinh operation_

Syntax:

```
operation ::= `chlo.asinh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Asinh(operand)` element-wise.

$$
\asinh(x) = log(x + sqrt(x^2 + 1))
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.atan` (chlo::AtanOp)

_Atan operator_

Syntax:

```
operation ::= `chlo.atan` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Atan(operand)` element-wise.

$$
\atan(x) = \atan2(x, 1)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.atanh` (chlo::AtanhOp)

_Atanh operator_

Syntax:

```
operation ::= `chlo.atanh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Atanh(operand)` element-wise.

$$
\atanh(x) = 0.5 * log((1 + x) / (1 - x)) if abs(x) <= 1
          = nan                          otherwise
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.bessel_i1e` (chlo::BesselI1eOp)

_Bessel function of order 1_

Syntax:

```
operation ::= `chlo.bessel_i1e` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `bessel_i1e(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.broadcast_add` (chlo::BroadcastAddOp)

_Addition operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_add` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs + rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `HLO_CompatibleOperandsAndResultElementType`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_and` (chlo::BroadcastAndOp)

_Logical and operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_and` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `logical_and(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of bool or int |
| `rhs` | tensor of bool or int |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_atan2` (chlo::BroadcastAtan2Op)

_Atan2 operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_atan2` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `atan2(lhs/rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_compare` (chlo::BroadcastCompareOp)

_Compare operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_compare` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Compares `lhs` and `rhs` elementwise according to `comparison_direction`
and `compare_type`. If unspecified, `compare_type` is FLOAT for float element
types, SIGNED for signed element types and UNSIGNED for unsigned element
types.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_comparison_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
<tr><td><code>comparison_direction</code></td><td>::mlir::chlo::ComparisonDirectionAttr</td><td>Which comparison operation to perform.</td></tr>
<tr><td><code>compare_type</code></td><td>::mlir::chlo::ComparisonTypeAttr</td><td>Which comparison type to use.</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of bool |



### `chlo.broadcast_complex` (chlo::BroadcastComplexOp)

_Complex operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_complex` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Performs element-wise conversion of a pair of real and imaginary values to
a complex value.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float |
| `rhs` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of complex |



### `chlo.broadcast_divide` (chlo::BroadcastDivOp)

_Division operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_divide` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs / rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_maximum` (chlo::BroadcastMaxOp)

_Maximum operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_maximum` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `max(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `HLO_CompatibleOperandsAndResultElementType`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_minimum` (chlo::BroadcastMinOp)

_Minimum operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_minimum` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `min(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `HLO_CompatibleOperandsAndResultElementType`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_multiply` (chlo::BroadcastMulOp)

_Multiplication operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_multiply` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs * rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_next_after` (chlo::BroadcastNextAfterOp)

_Std::nextafter operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_next_after` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns the next representable value of `lhs` in the direction of `rhs`,
element-wise. It can also return a subnormal number.

Equivalent to the C++ std::nextafter function.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_or` (chlo::BroadcastOrOp)

_Logical or operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_or` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `logical_or(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of bool or int |
| `rhs` | tensor of bool or int |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_polygamma` (chlo::BroadcastPolygammaOp)

_Polygamma function (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_polygamma` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `Polygamma(operand, operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_power` (chlo::BroadcastPowOp)

_Power operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_power` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs ^ rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_remainder` (chlo::BroadcastRemOp)

_Remainder operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_remainder` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs % rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_select` (chlo::BroadcastSelectOp)

_Select operator (with optional numpy-style broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_select` $pred `,` $on_true `,` $on_false attr-dict `:`
              `(` type($pred) `,` type($on_true) `,` type($on_false) `)` `->` type(results)
```

Constructs an output array from elements of two input arrays, based on the
values of a predicate array.

See https://www.tensorflow.org/xla/operation_semantics#select

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `pred` | ranked tensor of pred (AKA boolean or 1-bit integer) values |
| `on_true` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `on_false` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_shift_left` (chlo::BroadcastShiftLeftOp)

_Shift left operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_shift_left` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs << rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_shift_right_arithmetic` (chlo::BroadcastShiftRightArithmeticOp)

_Shift right arithmetic operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_shift_right_arithmetic` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs >> rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_shift_right_logical` (chlo::BroadcastShiftRightLogicalOp)

_Shift right logical operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_shift_right_logical` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs >> rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_subtract` (chlo::BroadcastSubOp)

_Subtraction operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_subtract` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `lhs - rhs` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_xor` (chlo::BroadcastXorOp)

_Logical xor operator (with optional broadcasting)_

Syntax:

```
operation ::= `chlo.broadcast_xor` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `logical_xor(lhs, rhs)` element-wise.

See
https://www.tensorflow.org/xla/operation_semantics#element-wise_binary_arithmetic_operations.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `Commutative`, `HLO_BroadcastingElementwise`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of bool or int |
| `rhs` | tensor of bool or int |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.broadcast_zeta` (chlo::BroadcastZetaOp)

_Hurwitz zeta function_

Syntax:

```
operation ::= `chlo.broadcast_zeta` $lhs `,` $rhs attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `->` type(results)
```

Returns `Zeta(operand, operand)` element-wise.

$$
\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultElementType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>broadcast_dimensions</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float |
| `rhs` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float |



### `chlo.conj` (chlo::ConjOp)

_Conj operator_

Syntax:

```
operation ::= `chlo.conj` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Conj(operand)` element-wise.

$$
\conj(x) = (\real(x), \neg(\imag(x)))
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.constant` (chlo::ConstantOp)

_Constant operator_

Syntax:

```
operation ::= `chlo.constant` attr-dict $value
```

Represents a constant value.

Traits: `AlwaysSpeculatableImplTrait`, `ConstantLike`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` | statically shaped tensor of f4E2M1FN type or f6E2M3FN type or f6E3M2FN type or f8E3M4 type or f8E4M3 type or f8E4M3FN type or f8E4M3FNUZ type or f8E4M3B11FNUZ type or f8E5M2 type or f8E5M2FNUZ type or f8E8M0FNU type or 16-bit float or 32-bit float or 64-bit float or bfloat16 type or pred (AKA boolean or 1-bit integer) or 2/4/8/16/32/64-bit signless integer or 2/4/8/16/32/64-bit unsigned integer or complex type with 32-bit float or 64-bit float elements or 2/4/8/16/32-bit uniform quantized signed integer or 2/4/8/16/32-bit uniform quantized unsigned integer values |



### `chlo.constant_like` (chlo::ConstantLikeOp)

_Constant like operator_

Returns a splat constant of the same shape as the operand.

Traits: `AlwaysSpeculatableImplTrait`, `CHLO_Broadcasting`, `HLO_BroadcastingElementwise`, `InferTensorType`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td>TypedAttr instance</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.cosh` (chlo::CoshOp)

_Cosh operator_

Syntax:

```
operation ::= `chlo.cosh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Cosh(operand)` element-wise.

$$
\cosh(x) = (e^x + e^-x) / 2
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.digamma` (chlo::DigammaOp)

_Digamma function_

Syntax:

```
operation ::= `chlo.digamma` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Digamma(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.erf` (chlo::ErfOp)

_Erfc operator_

Syntax:

```
operation ::= `chlo.erf` $operand attr-dict `:` type($operand) `->` type($result)
```

Computes the Gauss error function of `x` element-wise.

erf(x) = erf_impl(x)            if |x| < 1
       = 1 - erfc_impl(x)       otherwise

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.erf_inv` (chlo::ErfInvOp)

_Inverse Erf_

Syntax:

```
operation ::= `chlo.erf_inv` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `ErfInv(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.erfc` (chlo::ErfcOp)

_Erfc operator_

Syntax:

```
operation ::= `chlo.erfc` $operand attr-dict `:` type($operand) `->` type($result)
```

Computes an approximation of the error function complement (1 - erf(x)).

erfc(x) = erfc_impl(x)           if |x| > 1
        = 1 - erf_impl(x)        otherwise

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.is_inf` (chlo::IsInfOp)

_IsInf predicate_

Syntax:

```
operation ::= `chlo.is_inf` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns if a value is +/-inf element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of bool |



### `chlo.is_neg_inf` (chlo::IsNegInfOp)

_IsNegInf predicate_

Syntax:

```
operation ::= `chlo.is_neg_inf` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns if a value is -inf element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of bool |



### `chlo.is_pos_inf` (chlo::IsPosInfOp)

_IsPosInf predicate_

Syntax:

```
operation ::= `chlo.is_pos_inf` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns if a value is +inf element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of bool |



### `chlo.lgamma` (chlo::LgammaOp)

_Lgamma function_

Syntax:

```
operation ::= `chlo.lgamma` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Lgamma(operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.next_after` (chlo::NextAfterOp)

_Std::nextafter operator_

Syntax:

```
operation ::= `chlo.next_after` $x `,` $y attr-dict `:` type($x) `,` type($y) `->` type(results)
```

Returns the next representable value of `x` in the direction of `y`,
element-wise. It can also return a subnormal number.

Equivalent to the C++ std::nextafter function.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `x` | tensor of float |
| `y` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.polygamma` (chlo::PolygammaOp)

_Polygamma function_

Syntax:

```
operation ::= `chlo.polygamma` $n `,` $x attr-dict `:` type($n) `,` type($x) `->` type(results)
```

Returns `Polygamma(operand, operand)` element-wise.

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `n` | tensor of float |
| `x` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



### `chlo.ragged_dot` (chlo::RaggedDotOp)

_Computes a matmul over a single ragged dimension_

This operation takes three tensor args---lhs, rhs, and group_sizes---and
a "ragged_dot_dimension_numbers" attribute. Like dot_general, the lhs and
rhs are allowed arbitrary batch and contracting dimensions. Additionally,
the lhs is required to have one ragged dimension, and the rhs may have at
most one group dimension. The op has three modes, depending on the kind of
the lhs ragged dimension.

In mode 1, the shape-signature is `[b,m,k], [g,b,k,n], [b,g] -> [b,m,n]`.
Here the ragged dimension is an lhs non-contracting dimension (`m`). The
dimensions `b` and `k` represent batch and contracting dimensions
respectively. The rhs is required to have a group dimension (`g`).

In mode 2, the shape-signature is `[b,m,k], [b,k,n], [b,g] -> [g,b,m,n]`.
Here the ragged dimension is an lhs/rhs contracting dimension (`k`).

In mode 3, the shape-signature is `[b,m,k], [b,k,n], [g] -> [b,m,n]`. Here
the ragged dimension is an lhs/rhs batch dimension (`b`).


Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ragged_dot_dimension_numbers</code></td><td>::mlir::chlo::RaggedDotDimensionNumbersAttr</td><td>Attribute that models the dimension information for ragged dot.</td></tr>
<tr><td><code>precision_config</code></td><td>::mlir::ArrayAttr</td><td>Precision Config attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `rhs` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `group_sizes` | ranked tensor of 2/4/8/16/32/64-bit signless integer or 2/4/8/16/32/64-bit unsigned integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.sinh` (chlo::SinhOp)

_Sinh operation_

Syntax:

```
operation ::= `chlo.sinh` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Sinh(operand)` element-wise.

$$
\sinh(x) = (e^x - e^-x) / 2                     if |x| < 1
         = e^(x + log(1/2)) - e^(-x + log(1/2)) otherwise.
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.square` (chlo::SquareOp)

_Square operation_

Syntax:

```
operation ::= `chlo.square` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Square(operand)` element-wise.

$$
\square(x) = complex((x.real - x.imag) * (x.real + x.imag), x.real * x.imag * 2) if x is a complex number
           = x * x                                                               otherwise
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.tan` (chlo::TanOp)

_Tan operation_

Syntax:

```
operation ::= `chlo.tan` $operand attr-dict `:` type($operand) `->` type($result)
```

Returns `Tan(operand)` element-wise.

$$
\tan(x) = \sin(x) / \cos(x)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`, `Elementwise`, `SameOperandsAndResultShape`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float or complex |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float or complex |



### `chlo.top_k` (chlo::TopKOp)

_Finds values and indices of the `k` largest elements for the last dimension_

Syntax:

```
operation ::= `chlo.top_k` `(`$operand `,` `k` `=` $k`)` attr-dict `:`
              type($operand) `->` `(`type($values)`,` type($indices)`)`
```

If the input is a vector (rank-1), finds the `k` largest entries in the vector
and outputs their values and indices as vectors.  Thus `values[j]` is the
`j`-th largest entry in `input`, and its index is `indices[j]`.

For matrices (resp. higher rank input), computes the top `k` entries in each
row (resp. vector along the last dimension).  Thus,

    values.shape = indices.shape = input.shape[:-1] + [k]

If two elements are equal, the lower-index element appears first.

Traits: `AlwaysSpeculatableImplTrait`, `InferTensorType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>k</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |

#### Results:

| Result | Description |
| :----: | ----------- |
| `values` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |
| `indices` | tensor of float, int, bool, complex, per-tensor quantized, or per-axis quantized |



### `chlo.zeta` (chlo::ZetaOp)

_Hurwitz zeta function_

Syntax:

```
operation ::= `chlo.zeta` $x `,` $q attr-dict `:` type($x) `,` type($q) `->` type(results)
```

Returns `Zeta(operand, operand)` element-wise.

$$
\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\)
$$

Traits: `AlwaysSpeculatableImplTrait`, `CompatibleOperandsAndResultType`

Interfaces: `ConditionallySpeculatable`, `InferShapedTypeOpInterface`, `InferTypeOpInterface`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `x` | tensor of float |
| `q` | tensor of float |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of float |



## Attributes

### ComparisonDirectionAttr

_Which comparison operation to perform._

Syntax:

```
#chlo.comparison_direction<
  ::mlir::chlo::ComparisonDirection   # value
>
```

Enum cases:
* EQ (`EQ`)
* NE (`NE`)
* GE (`GE`)
* GT (`GT`)
* LE (`LE`)
* LT (`LT`)

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::mlir::chlo::ComparisonDirection` | an enum of type ComparisonDirection |

### ComparisonTypeAttr

_Which comparison type to use._

Syntax:

```
#chlo.comparison_type<
  ::mlir::chlo::ComparisonType   # value
>
```

Enum cases:
* NOTYPE (`NOTYPE`)
* FLOAT (`FLOAT`)
* TOTALORDER (`TOTALORDER`)
* SIGNED (`SIGNED`)
* UNSIGNED (`UNSIGNED`)

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::mlir::chlo::ComparisonType` | an enum of type ComparisonType |

### PrecisionAttr

_XLA precision for an operand. Has backend specific meaning._

Syntax:

```
#chlo.precision<
  ::mlir::chlo::Precision   # value
>
```

Enum cases:
* DEFAULT (`DEFAULT`)
* HIGH (`HIGH`)
* HIGHEST (`HIGHEST`)

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::mlir::chlo::Precision` | an enum of type Precision |

### RaggedDotDimensionNumbersAttr

_Attribute that models the dimension information for ragged dot._

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| lhsBatchingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| rhsBatchingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| lhsContractingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| rhsContractingDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| lhsRaggedDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |
| rhsGroupDimensions | `::llvm::ArrayRef<int64_t>` | Dimension |

## Enums

### ComparisonDirection

_Which comparison operation to perform._

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| EQ | `0` | EQ |
| NE | `1` | NE |
| GE | `2` | GE |
| GT | `3` | GT |
| LE | `4` | LE |
| LT | `5` | LT |

### ComparisonType

_Which comparison type to use._

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| NOTYPE | `0` | NOTYPE |
| FLOAT | `1` | FLOAT |
| TOTALORDER | `2` | TOTALORDER |
| SIGNED | `3` | SIGNED |
| UNSIGNED | `4` | UNSIGNED |

### Precision

_XLA precision for an operand. Has backend specific meaning._

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| DEFAULT | `0` | DEFAULT |
| HIGH | `1` | HIGH |
| HIGHEST | `2` | HIGHEST |
